---
title: "Skyline Get daily self efficacy and response efficacy scores"
output: html_notebook
date: 2019-09-12
---


```{r}
library(tidyverse)
library(lubridate)
```

Preprocessing
=====================================================

Efficacy scores were collected in:
- every 3 days evening questionnaires (!! bug in the plateform, question was presented every day for some participants -> need to work out which and take every 3 day measures)


```{r}
 #get filepaths

eff_evening_filepath = "~/Documents/STUDY/EEG-Tobacco/DATA/SURVEYS/Every3days"

cond_file = "~/Documents/STUDY/EEG-Tobacco/DATA/expe_condition.csv"


output_filepath = "~/Documents/STUDY/EEG-Tobacco/DATA/SURVEYS"

#read files

files_eff_eve <-dir(path= eff_evening_filepath, pattern = "*.csv") 

data_eff <-read.csv(file.path(eff_evening_filepath, files_eff_eve), header = TRUE, sep = ",", dec = ".", stringsAsFactors = FALSE)

# condition file
cond <- read_csv(cond_file)


#rename columns 
#- questions scoring: 0 = not at all; 100 = very much

data_eff <-rename(data_eff, date=EndDate, completed=Finished,
                  ID = Q1, 
                  r_eff1 = Q3_1, r_eff2 = Q3_2, 
                  s_eff1= Q4_1, s_eff2 = Q4_2, s_eff3= Q4_3, 
                  hope = Q7_1, 
                  quit_int = Q5
                  )

data_eff$ID<-as.factor(data_eff$ID)


cond <-rename(cond, ID = "Subject ID", condition = "Condition = Intervention", removed= "REMOVED")
cond$ID<-as.factor(cond$ID)

# merge cond and eff files to get information about particopants condition

df <- full_join(cond, data_eff)
df$ID<-as.factor(df$ID)
# remove un-used dataframes
rm(cond, data_eff)


#Replace missing values and keep only participants who were not removed
df$removed<-df$removed %>% replace(is.na(.), 0)
df<-df%>%filter(removed == 0)

#filter to get only completed = True
df<-df %>%filter(completed == 'True')


```

 Compute response and self efficacy scores
 ------------------------------------------

-> get the mean of all individual scores in each condition for each day
  - 1. define days 1-2-3 etc.. 
  - 2. count how many of each day per condition


```{r}
# first reduce number of columns to keep only those of interest
df <- select(df, ID, condition, date, r_eff1:quit_int )

# transform the columns for response and self efficacy that were charactuers in numeric tyoe           
df <-df %>% mutate_each(funs(as.numeric), -ID, -quit_int, -date) 

# add a counter for each row per ID (see 1.)
df <- df %>% 
  group_by(ID) %>% 
  mutate(n_day = row_number()) %>% 
  select(ID, condition, n_day, everything())

df$n_day<-as.factor(df$n_day)
df$condition <- as.factor(df$condition)

# count how many of each day per condition
# _> need to get summary per condition per day not repetition

n_rep <- df %>% group_by(condition, n_day) %>%
 summarize(count=n())

n_rep <-n_rep %>% drop_na()

# plot
ggplot(data= n_rep, aes(x = n_day, y=count)) +
  geom_point(mapping = aes(colour = condition) ) +
  ggtitle("Number of response per day - efficacy questionnaire")


 


```

- 3. Compute mean response and self efficacy score for each day for each pp

- 4. plot
!!! different number of data points per paricipant !!!



```{r}
# compute total score for re and se for each day and each participant

df <- df %>% group_by(ID, n_day) %>% 
  mutate(total_re= sum(r_eff1, r_eff2), 
         total_se= sum(s_eff1, s_eff2, s_eff3)
         )

# drop rows with NA

# compute mean totol of response and self efficacy score for each day for each condition
m_scores <- df %>% group_by(condition, n_day) %>% 
  summarize(mean_re= mean(total_re,na.rm=TRUE), 
            mean_se=mean(total_se, na.rm=TRUE))

m_scores <- left_join(m_scores, n_rep)

# plot on 2 different graph response efficacy and self efficacy
m_scores %>% gather("type", "score", 3:4 ) %>% 
  ggplot(data=., mapping=aes(x= n_day, y=score)) +
         geom_point(mapping = aes(colour=condition, size=count), alpha=1/3)+
        facet_wrap(~type)+
  geom_smooth(se=FALSE)+
  ggtitle("Mean scores for response and self efficacy per day per condition")


```





Get the difference between participant enrolled (= have a participant ID) and those who actually conpleted at least 1 survey

```{r}
# for data_day
test<-anti_join(cond, data_eff)
```




3. Collate data from all day and evening survey within the same dataframe

+ make sure we only look at data from real participant by taking only the IDs present on the condition file

```{r}
sum_data<- inner_join(cond, data_day_tmp, by = 'ID', copy=TRUE )
sum_data<-left_join(data_day_tmp,data_eve_tmp, by = 'ID', copy=TRUE)
sum_data<-left_join(sum_data, data_eff_tmp, by = 'ID', copy=TRUE)

## add information from condition file
sum_data<-left_join(sum_data, cond, by = 'ID', copy=TRUE)

# get only real participant in followup datasets

sum_data_followup <- inner_join(cond, data_followup, by = 'ID', copy=TRUE )

sum_data_followup_lab <- inner_join(cond, data_followup_lab, by = 'ID', copy=TRUE )


```



4. Overview of performance

Number of participants who completed 80% of daily surveys:

```{r}
sum(sum_data$day_msg >66)
```

Number of participants who completed between 50% and 80% of daily surveys:

```{r}
sum(sum_data$day_msg %in% 41:66)

```

Number of participants who completed less than 50% of daily surveys:

```{r}
sum(sum_data$day_msg %in% 1:40)
```

Number of participants who completed online follow up questionnaire:

```{r}
sum(sum_data_followup$completed == 'True')

```

Number of participants who completed lab based follow up questionnaire:
```{r}
sum(sum_data_followup_lab$completed == 'True')

```


Number of participants who dropped out from the start (ie. never completed an online survey):

```{r}
nrow(dropout)
```
















